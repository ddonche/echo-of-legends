import {locations, items} from data
import state

/// need to make sure generated items are always an array, even when empty
act ensure_array(x)
  if x == nil
    return []
  end

  t = x.valtype
  judge using t
    == "array": return x
    == "unit":  return []
    else:       return [x]
  end
end

act init_world
  say "Generating your starting settlement..."
  
  /// Create save directories
  attempt
    create_dir!("saves")
    create_dir!("saves/locations")
  rescue err
    say "Warning: Could not create save directories"
  end
  
  /// Generate starting location at (0, 0)
  location [= generate_location_at(0, 0)
  
  if location == nil
    return nil, nil
  end
  
  /// Create initial game state
  game_state [= {
    current_x: 0,
    current_y: 0
  }
  
  say "Welcome to" ++ location >> name + "!"
  return location, game_state
end

act generate_location_at(x, y)
  /// Generate a new settlement
  location [= locations::generate_settlement()
  
  if location == nil
    return nil
  end
  
  /// Add coordinates and discovery flag
  put_at!(location, "x", x)
  put_at!(location, "y", y)
  put_at!(location, "discovered", true)
  
  /// Populate each building with items
  i = 0
  for building in location >> buildings
    /// Generate items and mutate the building
    generated_items = items::populate_building_items(building >> type)
    building_list = location >> buildings
    current_building = building_list[i]
    update_at!(current_building, "items", generated_items)
    update_at!(building_list, i, current_building)
    update_at!(location, "buildings", building_list)
    i = i + 1
  end
  
  /// Save the location to disk
  state::save_location(location)
  
  return location
end

act get_or_create_location(x, y)
    /// Try to load from disk first
    location [= state::load_location(x, y)

    if location != nil
        /// Normalize any old saves that might have Nil/unit items
        location = normalize_location_items(location)
        return location
    end

    /// Location doesn't exist, generate it
    say "Discovering new territory..."
    return generate_location_at(x, y)
end

act look(location)
    building = get_current_building(location)

    say "===" ++ building >> name ++ "==="
    say building >> description

    items_list = ensure_array(building >> items)

    say "[dbg] items type = " ++ items_list.valtype
    item_count = items_list.count

    if item_count > 0
        say ""
        say "You see:"
        for item in items_list
            say "  -" ++ item >> name
        end
    else
        say ""
        say "There's nothing of interest here."
    end
end

act get_current_building(location)
  index = location >> current_building
  building = location >> buildings[index]
  return building
end

act list_buildings(location)
  say "===" ++ location >> name ++ "==="
  say "You can visit:"
  
  i = 0
  for building in location >> buildings
    marker = ""
    if i == location >> current_building
      marker = " (you are here)"
    end
    say "  " + i + "." ++ building >> name + marker
    i = i + 1
  end
end

act go_to_building(location, building_index)
  buildings_list = location >> buildings
  max_index = buildings_list.count
  
  if building_index >= 0 and building_index < max_index
    /// Update the current building index using update_at
    update_at!(location, "current_building", building_index)
    
    /// Show the new location
    say ""
    look(location)
  else
    say "There's no building with that number."
  end
  
  return location
end

act take_item(location, item_id)
    index = location >> current_building
    items_list = ensure_array(location >> buildings[index] >> items)
    
    /// Find the item and its index - match by name OR id
    item = nil
    item_index = -1
    i = 0
    for potential_item in items_list
        if potential_item >> id == item_id or potential_item >> name == item_id
            item = potential_item
            item_index = i
            stop
        end
        i = i + 1
    end
    
    if item == nil
        say "There's no such item here."
        return nil, location
    end
    
    say "You picked up:" ++ item >> name
    
    /// Delete from items list and update the building
    delete_at!(items_list, item_index)
    
    /// Get the building and update its items
    building_list = location >> buildings
    current_building = building_list[index]
    update_at!(current_building, "items", items_list)
    
    /// Update the location with the modified building
    update_at!(building_list, index, current_building)
    update_at!(location, "buildings", building_list)
    
    return item, location
end

act drop_item(location, item)
    index = location >> current_building
    
    /// Get items list and mutate it
    building_list = location >> buildings
    current_building = building_list[index]
    items_list = ensure_array(current_building >> items)
    
    /// Add item to the list
    put_last!(items_list, item)
    
    /// Update building and location
    update_at!(current_building, "items", items_list)
    update_at!(building_list, index, current_building)
    update_at!(location, "buildings", building_list)
    
    say "You dropped:" ++ item >> name
    
    return location
end